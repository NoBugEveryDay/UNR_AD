include(CMakeDependentOption)
option(USE_CUDA "Option for using CUDA" OFF)
cmake_dependent_option(USE_CUDA_AWARE_MPI "Option for using CUDA-aware MPI" OFF "USE_CUDA" OFF)
cmake_dependent_option(USE_NCCL "Option for using NCCL" OFF "USE_CUDA_AWARE_MPI" OFF)
cmake_dependent_option(USE_PIPELINE_TRANS "Option for using Pipeline transpose" OFF "USE_CUDA" OFF)
message(STATUS "Build PowerLLEL using CUDA: " ${USE_CUDA})
option(USE_GPTL "Option for using GPTL" OFF)
message(STATUS "Build PowerLLEL using GPTL: " ${USE_GPTL})
option(USE_C "Option for using C Binding" ON)
message(STATUS "Build PowerLLEL using C Binding: " ${USE_C})
option(USE_OMP "Option for using OpenMP" OFF)
message(STATUS "Build PowerLLEL using OpenMP: " ${USE_OMP})
cmake_dependent_option(USE_OMP_OFFLOAD "Option for using OpenMP offload" OFF "USE_OMP" OFF)
message(STATUS "Build PowerLLEL using OpenMP offload: " ${USE_OMP_OFFLOAD})
cmake_dependent_option(OMP_INTEL_OFFLOAD "Option for offloading to Intel devices" OFF "USE_OMP_OFFLOAD" OFF)
message(STATUS "Build PowerLLEL using OpenMP offload for Intel devices: " ${OMP_INTEL_OFFLOAD})
option(USE_PDD "Option for using PDD(Parallel Diagonal Dominant) Algorithm" OFF)
message(STATUS "Build PowerLLEL using PDD(Parallel Diagonal Dominant) Algorithm: " ${USE_PDD})
option(USE_PSIP "Option for using PSIP(Partial semi-implicit) scheme for viscous term" OFF)
message(STATUS "Build PowerLLEL using PSIP(Partial semi-implicit) scheme: " ${USE_PSIP})
option(USE_SP_POIS "Option for using Single-Precision Poisson solver" OFF)
message(STATUS "Build PowerLLEL using Single-Precision Poisson solver: " ${USE_SP_POIS})
option(USE_MKL "Option for using MKL FFT" OFF)
message(STATUS "Build PowerLLEL using MKL FFT: " ${USE_MKL})
option(USE_KMLFFT "Option for using Kunpeng KML_FFT" OFF)
message(STATUS "Build PowerLLEL using Kunpeng KML_FFT: " ${USE_KMLFFT})
cmake_dependent_option(USE_NBHALO "Option for using non-blocking halo exchange. It should be used with USE_PSIP=OFF" OFF "NOT USE_PSIP" OFF)
message(STATUS "Build PowerLLEL using non-blocking halo exchange: " ${USE_NBHALO})
cmake_dependent_option(USE_NBHALOBUF "Option for using buffers for non-blocking halo exchange. It should be used with USE_NBHALO=ON" OFF "USE_NBHALO" OFF)
message(STATUS "Build PowerLLEL using buffers for non-blocking halo exchange: " ${USE_NBHALOBUF})
option(USE_RDMA "Option for use native RDMA interface" OFF)
message(STATUS "Build PowerLLEL use native RDMA interface: " ${USE_RDMA})
option(USE_IBV "Option for use IB Verbs. It should be used with USE_RDMA=ON" OFF)
message(STATUS "Build PowerLLEL use IB Verbs: " ${USE_IBV})
option(USE_TH2A "Option for use GLEX RDMA interface on TH2A. It should be used with USE_RDMA=ON" OFF)
message(STATUS "Build PowerLLEL use GLEX RDMA interface on TH2A: " ${USE_TH2A})

file(GLOB _mods mod_*.f90)
list(FILTER _mods EXCLUDE REGEX ".*mod_device\\.f90$")
if(USE_CUDA)
    file(GLOB _mods mod_*.f90)
endif()

list(FILTER _mods EXCLUDE REGEX ".*mod_fft_mkl\\.f90$")
list(FILTER _mods EXCLUDE REGEX ".*mod_fft_kmlfft\\.f90$")
if(USE_MKL AND (NOT USE_C))
    string(REPLACE "mod_fft.f90" "mod_fft_mkl.f90" _mods "${_mods}")
elseif(USE_KMLFFT)
    string(REPLACE "mod_fft.f90" "mod_fft_kmlfft.f90" _mods "${_mods}")
endif()

if(USE_C)
    set(src ${_mods} main.f90 decomp2d/decomp_2d.f90 decomp_2d_c.f90)
else()
    set(src ${_mods} main.f90 decomp2d/decomp_2d.f90)
endif()
list(APPEND src gptlf.f90)

add_executable(PowerLLEL ${src})
install(TARGETS PowerLLEL)
set_target_properties(PowerLLEL PROPERTIES OUTPUT_NAME "PowerLLEL${PowerLLEL_SUFFIX}")

set(CMAKE_Fortran_FLAGS "${CMAKE_Fortran_FLAGS} -cpp")

if (CMAKE_COMPILER_IS_GNUCC)
    execute_process(COMMAND ${CMAKE_C_COMPILER} -dumpfullversion -dumpversion OUTPUT_VARIABLE GCC_VERSION)
    string(REGEX MATCHALL "[0-9]+" GCC_VERSION_COMPONENTS ${GCC_VERSION})
    list(GET GCC_VERSION_COMPONENTS 0 GCC_MAJOR)
    list(GET GCC_VERSION_COMPONENTS 1 GCC_MINOR)
    set(GCC_VERSION "${GCC_MAJOR}.${GCC_MINOR}")
    message(STATUS "GCC version=${GCC_VERSION}")

    if (GCC_VERSION VERSION_GREATER_EQUAL "10")
        set(CMAKE_Fortran_FLAGS "${CMAKE_Fortran_FLAGS} -fallow-argument-mismatch")    
    endif()

    set(CMAKE_Fortran_FLAGS "${CMAKE_Fortran_FLAGS} -ffree-line-length-none")
endif()

if(USE_CUDA)
    set(CMAKE_Fortran_FLAGS "${CMAKE_Fortran_FLAGS} -cuda -cudalib=cufft")
    target_compile_definitions(PowerLLEL PRIVATE -D_CUDA)
    if(USE_CUDA_AWARE_MPI)
        target_compile_definitions(PowerLLEL PRIVATE -DCUDA_AWARE_MPI)
        if(USE_NCCL)
            set(CMAKE_Fortran_FLAGS "${CMAKE_Fortran_FLAGS} -cudalib=nccl")
            target_compile_definitions(PowerLLEL PRIVATE -DNCCL)
        endif()
    endif()
    if(USE_PIPELINE_TRANS)
        target_compile_definitions(PowerLLEL PRIVATE -DPIPELINE_TRANS)
    endif()
endif()

find_package(MPI REQUIRED)
target_link_libraries(PowerLLEL ${MPI_Fortran_LIBRARIES})
target_include_directories(PowerLLEL PRIVATE ${MPI_C_INCLUDE_DIRS})

if(NOT USE_C)
    find_package(HDF5 COMPONENTS Fortran)
    target_include_directories(PowerLLEL PUBLIC ${HDF5_INCLUDE_DIRS})
    target_link_libraries(PowerLLEL ${HDF5_Fortran_LIBRARIES})
endif()

if(USE_OMP)
    find_package(OpenMP)
    target_include_directories(PowerLLEL PUBLIC ${OpenMP_Fortran_INCLUDE_DIRS})
    target_link_libraries(PowerLLEL ${OpenMP_Fortran_LIBRARIES})
    target_compile_options(PowerLLEL PUBLIC ${OpenMP_Fortran_FLAGS})
    target_link_options(PowerLLEL PUBLIC ${OpenMP_Fortran_FLAGS})
endif()

find_package(PkgConfig REQUIRED)

if(USE_MKL)
    target_compile_definitions(PowerLLEL PRIVATE -DUSE_MKL)
    target_link_libraries(PowerLLEL mkl_intel_lp64 mkl_sequential mkl_core)
elseif(USE_KMLFFT)
    target_include_directories(PowerLLEL PRIVATE $ENV{KML_INC})
    target_link_directories(PowerLLEL PRIVATE $ENV{KML_LIB})
    target_link_libraries(PowerLLEL kfft)
else()
if(USE_SP_POIS)
    pkg_check_modules(FFTW3f REQUIRED fftw3f IMPORTED_TARGET)
    target_link_directories(PowerLLEL PRIVATE ${FFTW3f_LIBRARY_DIRS})
    target_link_libraries(PowerLLEL ${FFTW3f_LIBRARIES})
else()
    pkg_check_modules(FFTW3 REQUIRED fftw3 IMPORTED_TARGET)
    target_link_directories(PowerLLEL PRIVATE ${FFTW3_LIBRARY_DIRS})
    target_link_libraries(PowerLLEL ${FFTW3_LIBRARIES})
endif()
endif()

if(USE_GPTL)
    pkg_search_module(GPTL REQUIRED gptl)
    target_link_directories(PowerLLEL PRIVATE ${GPTL_LIBRARY_DIRS})
    target_link_libraries(PowerLLEL ${GPTL_LIBRARIES})
    target_compile_definitions(PowerLLEL PRIVATE -DGPTL)
endif()

if(USE_C OR USE_RDMA)
    add_subdirectory(src_c)
    target_link_libraries(PowerLLEL c_binding)
    if(USE_C)
        target_compile_definitions(PowerLLEL PRIVATE -DUSE_C)
    endif()
    if(USE_RDMA)
        target_link_libraries(PowerLLEL unr)
        target_compile_definitions(PowerLLEL PRIVATE -DUSE_RDMA)
        if(USE_IBV)
            target_link_libraries(PowerLLEL ibverbs)
        endif()
    endif()
endif()

if(USE_PDD)
    target_compile_definitions(PowerLLEL PRIVATE -D_PDD)
endif()

if(USE_PSIP)
    target_compile_definitions(PowerLLEL PRIVATE -DPSIP)
endif()

if(USE_SP_POIS)
    target_compile_definitions(PowerLLEL PRIVATE -DSP_POIS)
endif()

target_compile_definitions(PowerLLEL PRIVATE -D_PRECALC_TRID_COEFF)

if(USE_NBHALO)
    target_compile_definitions(PowerLLEL PRIVATE -DNB_HALO)
    if(USE_NBHALOBUF)
        target_compile_definitions(PowerLLEL PRIVATE -DUSE_NBHALOBUF)
    endif()
endif()
